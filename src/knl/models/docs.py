"""
Pydantic models for documentation updates.

These models define the structure of documentation update proposals
generated by the MCP server and processed by the knl docs commands.
"""

from datetime import datetime
from enum import Enum
from pathlib import Path

from pydantic import BaseModel, Field

from ..utils import dt


class UpdateType(str, Enum):
    """Type of documentation update."""

    REPLACE = "replace"  # Replace old text with new text
    INSERT = "insert"  # Insert new text at position
    APPEND = "append"  # Append text to end of file/section
    DELETE = "delete"  # Delete specified text


class Severity(str, Enum):
    """Severity of documentation gap."""

    CRITICAL = "critical"  # Missing critical docs (new CLI flags, breaking changes)
    HIGH = "high"  # Important missing docs (new features, major changes)
    MEDIUM = "medium"  # Moderate gaps (minor features, improvements)
    LOW = "low"  # Nice-to-have updates (typos, clarifications)


class DocUpdate(BaseModel):
    """A single documentation update operation."""

    type: UpdateType
    old: str | None = Field(
        None, description="Text to replace (for REPLACE) or find (for INSERT position)"
    )
    new: str = Field(..., description="New text to insert/append/replace")
    reason: str = Field(..., description="Why this update is needed")
    severity: Severity = Field(
        Severity.MEDIUM, description="How critical this update is"
    )
    line_number: int | None = Field(
        None, description="Suggested line number for insert/replace"
    )

    class Config:
        """Pydantic configuration."""

        json_schema_extra = {
            "example": {
                "type": "replace",
                "old": "curl -LsSf https://example.com/install.sh | sh",
                "new": "curl -LsSf https://example.com/install.sh | sh -s -- --compiled",
                "reason": "Add example showing --compiled flag usage",
                "severity": "high",
                "line_number": 42,
            }
        }


class FileUpdate(BaseModel):
    """Updates for a single file."""

    path: Path = Field(..., description="Path to file to update")
    updates: list[DocUpdate] = Field(
        default_factory=list, description="List of updates for this file"
    )
    file_type: str = Field(
        ..., description="Type of file (markdown, python, toml, etc)"
    )
    section: str | None = Field(
        None, description="Specific section being updated (e.g., 'Installation')"
    )

    @property
    def critical_count(self) -> int:
        """Count of critical updates."""
        return sum(1 for u in self.updates if u.severity == Severity.CRITICAL)

    @property
    def high_count(self) -> int:
        """Count of high priority updates."""
        return sum(1 for u in self.updates if u.severity == Severity.HIGH)

    def get_by_severity(self, severity: Severity) -> list[DocUpdate]:
        """Get updates filtered by severity."""
        return [u for u in self.updates if u.severity == severity]

    class Config:
        """Pydantic configuration."""

        json_schema_extra = {
            "example": {
                "path": "README.md",
                "updates": [
                    {
                        "type": "replace",
                        "old": "# Install",
                        "new": "# Install\n\n## Compiled Binary\n\nUse --compiled flag...",
                        "reason": "Document new compiled installation mode",
                        "severity": "high",
                    }
                ],
                "file_type": "markdown",
                "section": "Installation",
            }
        }


class DocGap(BaseModel):
    """Identified documentation gap."""

    gap_type: str = Field(
        ..., description="Type of gap (missing_cli_help, outdated_example, etc)"
    )
    description: str = Field(..., description="Description of the gap")
    severity: Severity = Field(..., description="How critical this gap is")
    affected_files: list[Path] = Field(
        default_factory=list, description="Files affected by this gap"
    )
    code_reference: str | None = Field(
        None, description="Reference to code causing the gap (file:line)"
    )
    suggested_action: str = Field(..., description="What should be done")

    class Config:
        """Pydantic configuration."""

        json_schema_extra = {
            "example": {
                "gap_type": "missing_cli_help",
                "description": "New --compiled flag not documented in README installation section",
                "severity": "high",
                "affected_files": ["README.md", "docs/installation.md"],
                "code_reference": "install.sh:732",
                "suggested_action": "Add section explaining --compiled flag benefits and usage",
            }
        }


class ChangelogEntry(BaseModel):
    """A changelog entry."""

    version: str | None = Field(None, description="Version number (e.g., '1.2.0')")
    date: datetime = Field(
        default_factory=dt.now, description="Date of change"
    )
    category: str = Field(
        ..., description="Category (Added, Changed, Fixed, etc)"
    )
    description: str = Field(..., description="Change description")
    related_pr: str | None = Field(None, description="Related PR/issue number")

    class Config:
        """Pydantic configuration."""

        json_schema_extra = {
            "example": {
                "version": "1.2.0",
                "date": "2026-01-02",
                "category": "Added",
                "description": "Compiled binary installation mode with --compiled flag",
                "related_pr": "#1",
            }
        }


class DocUpdateProposal(BaseModel):
    """Complete documentation update proposal from MCP server."""

    task_id: str | None = Field(None, description="Task ID this proposal is for")
    scope: str = Field(..., description="Scope of analysis (task, release, all)")
    analyzed_at: datetime = Field(
        default_factory=dt.now, description="When analysis was performed"
    )

    # Analysis results
    gaps: list[DocGap] = Field(
        default_factory=list, description="Identified documentation gaps"
    )
    files: list[FileUpdate] = Field(
        default_factory=list, description="Proposed file updates"
    )
    changelog_entries: list[ChangelogEntry] = Field(
        default_factory=list, description="Proposed changelog entries"
    )

    # Metadata
    commits_analyzed: int = Field(0, description="Number of commits analyzed")
    files_changed: int = Field(0, description="Number of code files changed")
    confidence: float = Field(
        0.0,
        ge=0.0,
        le=1.0,
        description="AI confidence in analysis (0.0-1.0)",
    )

    @property
    def total_updates(self) -> int:
        """Total number of proposed updates."""
        return sum(len(f.updates) for f in self.files)

    @property
    def critical_gaps(self) -> list[DocGap]:
        """Critical documentation gaps."""
        return [g for g in self.gaps if g.severity == Severity.CRITICAL]

    @property
    def files_by_priority(self) -> list[FileUpdate]:
        """Files sorted by priority (most critical updates first)."""
        return sorted(
            self.files,
            key=lambda f: (f.critical_count, f.high_count),
            reverse=True,
        )

    def summary(self) -> str:
        """Generate a summary of the proposal."""
        return (
            f"Analysis: {self.scope}\n"
            f"Gaps found: {len(self.gaps)} ({len(self.critical_gaps)} critical)\n"
            f"Files to update: {len(self.files)}\n"
            f"Total updates: {self.total_updates}\n"
            f"Changelog entries: {len(self.changelog_entries)}\n"
            f"Confidence: {self.confidence:.1%}"
        )


class ApprovalDecision(str, Enum):
    """User's decision on an update."""

    ACCEPT = "accept"  # Apply this update
    REJECT = "reject"  # Skip this update
    EDIT = "edit"  # User wants to modify the update
    SKIP = "skip"  # Skip for now, ask again later


class UpdateApproval(BaseModel):
    """User approval for a specific update."""

    file_path: Path
    update_index: int  # Index in FileUpdate.updates list
    decision: ApprovalDecision
    edited_text: str | None = Field(
        None, description="Modified text if decision was EDIT"
    )
    notes: str | None = Field(None, description="User notes about the decision")


class ApprovalSession(BaseModel):
    """Complete approval session for a proposal."""

    proposal_id: str = Field(
        ..., description="Unique ID for this proposal (for tracking)"
    )
    started_at: datetime = Field(
        default_factory=dt.now, description="When approval started"
    )
    completed_at: datetime | None = Field(None, description="When approval finished")

    approvals: list[UpdateApproval] = Field(
        default_factory=list, description="User decisions"
    )

    @property
    def accepted_count(self) -> int:
        """Number of accepted updates."""
        return sum(1 for a in self.approvals if a.decision == ApprovalDecision.ACCEPT)

    @property
    def rejected_count(self) -> int:
        """Number of rejected updates."""
        return sum(1 for a in self.approvals if a.decision == ApprovalDecision.REJECT)

    @property
    def edited_count(self) -> int:
        """Number of edited updates."""
        return sum(1 for a in self.approvals if a.decision == ApprovalDecision.EDIT)

    def summary(self) -> str:
        """Generate approval summary."""
        total = len(self.approvals)
        return (
            f"Reviewed: {total} updates\n"
            f"Accepted: {self.accepted_count}\n"
            f"Edited: {self.edited_count}\n"
            f"Rejected: {self.rejected_count}"
        )


class DocCheckResult(BaseModel):
    """Results from knl docs check command."""

    checked_at: datetime = Field(
        default_factory=dt.now, description="When check was performed"
    )
    scope: str = Field(..., description="What was checked")

    # Results
    cli_help_gaps: list[str] = Field(
        default_factory=list, description="CLI help vs docs mismatches"
    )
    example_errors: list[str] = Field(
        default_factory=list, description="Incorrect examples found"
    )
    missing_changelog: bool = Field(
        False, description="Whether changelog is missing entries"
    )
    outdated_files: list[Path] = Field(
        default_factory=list, description="Files that appear outdated"
    )

    @property
    def is_clean(self) -> bool:
        """Whether all checks passed."""
        return (
            not self.cli_help_gaps
            and not self.example_errors
            and not self.missing_changelog
            and not self.outdated_files
        )

    @property
    def total_issues(self) -> int:
        """Total number of issues found."""
        return (
            len(self.cli_help_gaps)
            + len(self.example_errors)
            + (1 if self.missing_changelog else 0)
            + len(self.outdated_files)
        )

    def summary(self) -> str:
        """Generate check summary."""
        if self.is_clean:
            return "âœ“ All documentation checks passed!"

        return (
            f"Found {self.total_issues} documentation issues:\n"
            f"  CLI help gaps: {len(self.cli_help_gaps)}\n"
            f"  Example errors: {len(self.example_errors)}\n"
            f"  Missing changelog: {'Yes' if self.missing_changelog else 'No'}\n"
            f"  Outdated files: {len(self.outdated_files)}"
        )
